// has assumptions and cover points to emulate appropriate environment and binds them to alu design file

module alu_fv
  import ariane_pkg::*;
  import formal_pkg::*;  //has definitions of datatype fu_data_t
#(
    parameter config_pkg::cva6_cfg_t CVA6Cfg = build_config_pkg::build_config(
        cva6_config_pkg::cva6_cfg), //<--- Modified line
    parameter bit HasBranch = 1'b1,
    //parameter type fu_data_t = logic
    parameter type fu_data_t = formal_pkg::fu_data_t // <--- Modified line
    

) (
    // Subsystem Clock - SUBSYSTEM
    input logic clk_i,
    // Asynchronous reset active low - SUBSYSTEM
    input logic rst_ni,
    // FU data needed to execute instruction - ISSUE_STAGE
    input fu_data_t fu_data_i,
    // ALU result - ISSUE_STAGE
    input logic [CVA6Cfg.XLEN-1:0] result_o,
    // ALU branch compare result - branch_unit
    input logic alu_branch_res_o
);

// Macros to shorten notation (referencing ALU ports directly)
  `define A  fu_data_i.operand_a
  `define B  fu_data_i.operand_b
  `define OP fu_data_i.operation

   logic [31:0] shift_val=$signed(`A) >>> `B[4:0];
  // --- Assumptions (Combinational) ---
  assume property (!$isunknown(fu_data_i));
  assume property (fu_data_i.fu == ALU);
  assume property (`OP inside {ADD,SUB,ANDL,ORL,XORL,SLL,SRL,SRA,EQ,NE,LTS,LTU,GES,GEU,SLTS,SLTU});

//clock signal is not used ,because the cva6 ALU is completely combinational and independent of the clock.

  // --- Assertions (Combinational) ---
  assert property (`OP == ADD |-> result_o == (`A + `B));
  assert property (`OP == SUB |-> result_o == (`A - `B));
  assert property (`OP == ANDL |-> result_o == (`A & `B));
  assert property (`OP == ORL  |-> result_o == (`A | `B));
  assert property (`OP == XORL |-> result_o == (`A ^ `B));

  assert property (`OP == SLL |-> result_o == (`A << `B[4:0]));
  assert property (`OP == SRL |-> result_o == (`A >> `B[4:0]));
  assert property (`OP == SRA |-> result_o == ( shift_val));


  assert property (`OP == EQ  |-> alu_branch_res_o == (`A == `B));
  assert property (`OP == NE  |-> alu_branch_res_o == (`A != `B));
  assert property (`OP == LTS |-> alu_branch_res_o == ($signed(`A) <  $signed(`B)));
  assert property (`OP == LTU |-> alu_branch_res_o == (`A <  `B));
  assert property (`OP == GES |-> alu_branch_res_o == ($signed(`A) >= $signed(`B)));
  assert property (`OP == GEU |-> alu_branch_res_o == ($unsigned(`A) >= $unsigned(`B)));

  // --- Covers (Combinational) ---
  cover property (`OP == ADD);
  cover property (`OP == SLL && `B[4:0] == 0);
  cover property (`OP == SLL && `B[4:0] == 31);
  cover property (`OP == SUB);
  cover property (`OP == ANDL);
  cover property (`OP == ORL);
  cover property (`OP == XORL);
  cover property (`OP == SRL);
  cover property (`OP == SRA);
  cover property (`OP == EQ);
  cover property (`OP == NE);
  cover property (`OP == LTS);
  cover property (`OP == LTU);
  cover property (`OP == GES);
  cover property (`OP == GEU);




endmodule

bind alu alu_fv alu_fv_i(.*);
